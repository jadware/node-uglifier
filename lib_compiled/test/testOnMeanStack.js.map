{
  "version": 3,
  "file": "testOnMeanStack.js",
  "sourceRoot": "..\\..",
  "sources": [
    "src\\test\\testOnMeanStack.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;AAAA,MAAA,uBAAA,EAAA,YAAA,EAAA,EAAA,EAAA,YAAA,EAAA;;EAAA,EAAA,GAAK,OAAA,CAAQ,IAAR;;EACL,YAAA,GAAa,OAAA,CAAQ,iBAAR;;EACb,YAAA,GAAa,OAAA,CAAQ,sBAAR;;EACb,IAAA,GAAO,OAAA,CAAQ,MAAR,EAHP;;;EAMA,uBAAA,GAAwB,MANxB;;;;;;;;;;;;;;;;EAyBA,OAAO,CAAC,SAAR,GAAkB,QAAA,CAAC,IAAD,CAAA;AAChB,QAAA,YAAA,EAAA,kBAAA,EAAA,YAAA,EAAA,oBAAA,EAAA,iBAAA,EAAA;IAAA,eAAA,GAAkB;IAClB,iBAAA,GAAkB;IAClB,YAAA,GAAe,IAAI,YAAJ,CAAiB,4CAAjB,EAA8D;MAAC,OAAA,EAAQ;IAAT,CAA9D;IACf,YAAA,GAAe,YAAY,CAAC,KAAb,CAAA;IACf,kBAAA,GAAmB,YAAY,CAAC,QAAb,CAAA;IAEnB,IAAG,uBAAH;MAAgC,YAAY,CAAC,YAAb,CAA0B,iBAAA,GAAoB,iCAA9C,EAAhC;;IAEA,oBAAA,GAAuB,YAAY,CAAC,MAAb,CAAoB;MACzC,gBAAA,EAAkB;IADuB,CAApB,CAErB,CAAC,QAFoB,CAAA;IAIvB,IAAG,uBAAH;MAAiC,YAAY,CAAC,YAAb,CAA0B,iBAAA,GAAoB,oBAA9C,EAAjC;;IACA,IAAG,uBAAH;MAAiC,YAAY,CAAC,gBAAb,CAA8B,eAA9B,EAAjC;;IAEA,IAAI,CAAC,MAAL,CAAY,YAAY,CAAC,QAAb,CAAsB,iBAAA,GAAoB,iCAA1C,CAA4E,CAAC,QAA7E,CAAA,CAAZ,EAAoG,kBAApG;IACA,IAAI,CAAC,MAAL,CAAY,YAAY,CAAC,QAAb,CAAsB,iBAAA,GAAoB,oBAA1C,CAA+D,CAAC,QAAhE,CAAA,CAAZ,EAAuF,oBAAvF;WAEA,IAAI,CAAC,IAAL,CAAA;EAnBgB;AAzBlB",
  "sourcesContent": [
    "fs = require('fs');\r\nNodeUglifier=require(\"../NodeUglifier\")\r\npackageUtils=require('../libs/packageUtils')\r\npath = require('path')\r\n#_=require(\"\\x6e\\x64\\x65\\x72\\x73\\x63\\x6f\\x72\\x65\\x6e\")\r\n\r\nIS_RE_CREATE_TEST_FILES=false\r\n\r\n#with mean stack there were multiple problems in 0.1.8\r\n#\r\n#there were some fancy require statements where there were multiple parentheses after require like:\r\n#  require('./config/express')(db)\r\n#in this case the require AST node had the first argument (db) and not the actual path.\r\n#This has been resolved by giving precedence to the left most expression, that is the deeper in the parse tree\r\n#\r\n#The other problem was naming files the same as modules like in the case of express.js\r\n#the logic assumed if a required file is found in the folder of the file in which the require statement is, than it is not module...\r\n#Clearly I did not mimick the behaviour of the node require well\r\n#This has been resolved by checking if there is / or \\ in the require path argument, if not it is assumed to be module\r\n#\r\n#On the other hand it has also dynamic require statements, which obviously will not work...\r\n# So this test tests only what supposed to work.\r\n\r\n\r\n\r\nexports.testStuff=(test)->\r\n  uglifySourceMap = \"lib_compiled/test/resultFiles/sourcemaps/server.sourcemaps.js\";\r\n  uglifyReultFolder=\"lib_compiled/test/resultFiles/\"\r\n  nodeUglifier = new NodeUglifier(\"./lib_compiled/test/testproject2/server.js\",{rngSeed:\"hello\"});\r\n  mergedSource = nodeUglifier.merge();\r\n  mergedSourceString=mergedSource.toString()\r\n\r\n  if IS_RE_CREATE_TEST_FILES then nodeUglifier.exportToFile(uglifyReultFolder + \"server.compiled_not_uglified.js\");\r\n\r\n  uglifiedSourceString = mergedSource.uglify({\r\n    strProtectionLvl: 1\r\n  }).toString();\r\n\r\n  if IS_RE_CREATE_TEST_FILES then  nodeUglifier.exportToFile(uglifyReultFolder + \"server.compiled.js\");\r\n  if IS_RE_CREATE_TEST_FILES then  nodeUglifier.exportSourceMaps(uglifySourceMap);\r\n\r\n  test.equals(packageUtils.readFile(uglifyReultFolder + \"server.compiled_not_uglified.js\").toString(),mergedSourceString)\r\n  test.equals(packageUtils.readFile(uglifyReultFolder + \"server.compiled.js\").toString(),uglifiedSourceString)\r\n\r\n  test.done()"
  ]
}